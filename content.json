{"meta":{"title":"MT","subtitle":"","description":"一个小菜鸟的学习旅途","author":"Tian Ming","url":"https://mtianming.top","root":"/"},"pages":[],"posts":[{"title":"悲惨的线代学习生活","slug":"悲惨的线代学习生活","date":"2021-12-23T15:22:39.000Z","updated":"2021-12-23T15:25:21.191Z","comments":true,"path":"2021/12/23/悲惨的线代学习生活/","link":"","permalink":"https://mtianming.top/2021/12/23/%E6%82%B2%E6%83%A8%E7%9A%84%E7%BA%BF%E4%BB%A3%E5%AD%A6%E4%B9%A0%E7%94%9F%E6%B4%BB/","excerpt":"","text":"悲惨的线代学习生活","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"https://mtianming.top/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"高数-上作业答案","slug":"高数-上作业答案","date":"2021-12-19T23:29:42.000Z","updated":"2021-12-19T23:45:45.783Z","comments":true,"path":"2021/12/20/高数-上作业答案/","link":"","permalink":"https://mtianming.top/2021/12/20/%E9%AB%98%E6%95%B0-%E4%B8%8A%E4%BD%9C%E4%B8%9A%E7%AD%94%E6%A1%88/","excerpt":"","text":"","categories":[],"tags":[{"name":"高等数学","slug":"高等数学","permalink":"https://mtianming.top/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"}]},{"title":"校初选单片机方向","slug":"校初选单片机方向","date":"2021-12-18T07:53:42.000Z","updated":"2021-12-19T15:08:17.439Z","comments":true,"path":"2021/12/18/校初选单片机方向/","link":"","permalink":"https://mtianming.top/2021/12/18/%E6%A0%A1%E5%88%9D%E9%80%89%E5%8D%95%E7%89%87%E6%9C%BA%E6%96%B9%E5%90%91/","excerpt":"","text":"校初选单片机方向 往年题目 定时器PWM模式 （以下开启的是定时器3，用于PWM输出） 123456/* USER CODE BEGIN 2 */HAL_TIM_PWM_Start(&amp;htim3,TIM_CHANNEL_1);//将对应的定时器对应的通道打开，注意注意注意将这句话放在user code begin2后面TIM3-&gt;PSC=XXX; //根据自己要的频率计算TIM3-&gt;ARR=XXX; //根据自己要的频率计算TIM3-&gt;CCR1=XXX; //ccr加数字对应的就是哪一个通道的ccr，根据自己要的占空比计算 定时器输入捕获模式我们要解算所输入信号的频率，占空比等信息 设置全局变量： 12345678/* Private variables --------------------------*//* USER CODE BEGIN PV */float duty;float freq;/* USER CODE END PV *//* Private function prototypes -----------------*/ 开启两个输入捕获中断： 12HAL_TIM_IC_Start_IT(&amp;htim2, TIM_CHANNEL_1);HAL_TIM_IC_Start_IT(&amp;htim2, TIM_CHANNEL_2); 中断回调函数：（计算freq &amp; duty） 123456789void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)&#123; if (htim-&gt;Instance == TIM2)&#123; if (htim-&gt;Channel == HAL_TIM_ACTIVE_CHANNEL_1)&#123; freq = 84000000.0f / TIM2-&gt;CCR1; duty = (float)TIM2-&gt;CCR2 / TIM2-&gt;CCR1; &#125; &#125;&#125; 定时器输出比较模式比较输出【Compare Output】功能：定时器通过对预设的比较值与计数器的值做匹配比较之后，并依据相应的输出模式从而实现各类输出。如PWM输出、电平翻转、单脉冲输出、强制输出等。","categories":[],"tags":[{"name":"单片机学习","slug":"单片机学习","permalink":"https://mtianming.top/tags/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/"}]},{"title":"悲惨的高数学习生活1","slug":"悲惨的高数学习生活1","date":"2021-12-12T12:40:08.000Z","updated":"2021-12-23T15:13:03.714Z","comments":true,"path":"2021/12/12/悲惨的高数学习生活1/","link":"","permalink":"https://mtianming.top/2021/12/12/%E6%82%B2%E6%83%A8%E7%9A%84%E9%AB%98%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%94%9F%E6%B4%BB1/","excerpt":"","text":"高数笔记-1悲剧的是，距离期末考试还有不到一个月的时间 第一章：极限与连续1.2数列的极限1.数列极限的定义 找到N最重要 2.收敛数列的性质收敛数列的极限唯一； 收敛数列一定有界，但有界不一定收敛； 收敛数列具有保号性； 收敛数列的任一子数列收敛于同一极限； 1.3函数的极限 1.4无穷小量与无穷大量 （注意0） 1.5极限运算法则 （∞/∞） 1.6极限存在准则 两个重要极限 （1、需要自己构造g(x)和f(x)，因此夹逼定理不太好用；2、放缩；） （主要是求极限） 1.7无穷小的比较（函数上升的速度） （等价无穷小（x-&gt;0）替换） 1.8函数的连续性与间断点 （通过和差化积，使求极限时更为方便） 1.9闭区间上连续函数的性质 （两个连续的函数） 第二章：导数与微分2.1导数的定义 （分段函数） 求切线方程，先设切点为(x0,y0)，写出切线方程y - 0 = kx（k用所切函数求导后代入得x0表达式表示），最后联立这个式子和所切函数的式子。 2.2求导法则 2.3高阶导数及相关变化率 （二阶参数方程求导） （n阶求导） 2.4微分 第三章：微分中值定理与导数的应用3.1微分中值定理1.1费马引理 导数为零的点叫驻点，不一定是极值点。 1.2罗尔定理 1.3拉格朗日中值定理 1.4柯西中值定理 3.2洛必达法则 每求完一次检查一次 Lin(x^n) &lt; x^n &lt; e^x 转化为0/0型 将趋于常数的向外移或者直接先算出来 3.3泰勒公式 所有等价无穷小都可以用泰勒公式解释，用泰勒公式会更加精确 （常见的马克劳林展开式） 第四章：不定积分4.1不定积分的概念与性质 4.2换元积分法第一类换元法： 第二类换元法： （宋浩《高等数学》P42有大量题） 4.3分部积分法 4.4有理函数和可化为有理函数的积分 （待定系数法） 第五章：定积分及其应用5.1 定积分的概念 5.2定积分的性质 （估计定积分的范围） （定积分的中值定理） 5.3微积分基本定理 5.4定积分的换元法与分部积分法 5.5广义积分无穷限： 无界函数： 瑕积分具有欺骗性：要先是否是瑕积分再算 伽马函数： 5.6定积分的几何应用5.7定积分的物理应用 第六章：常微分方程6.1微分方程的基本概念 6.2一阶微分方程 6.3高阶线性微分方程 6.4微分方程的应用 （未完待续…）","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"https://mtianming.top/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Openmv-1","slug":"Openmv-1","date":"2021-12-12T05:11:53.000Z","updated":"2021-12-12T05:17:29.154Z","comments":true,"path":"2021/12/12/Openmv-1/","link":"","permalink":"https://mtianming.top/2021/12/12/Openmv-1/","excerpt":"","text":"Openmv-1 https://book.openmv.cc/quick-starter.html https://www.cnblogs.com/Llingfeng/p/14904689.html","categories":[],"tags":[{"name":"视觉","slug":"视觉","permalink":"https://mtianming.top/tags/%E8%A7%86%E8%A7%89/"}]},{"title":"C-Learning-2","slug":"C-Learning-2","date":"2021-12-10T05:59:26.000Z","updated":"2021-12-15T01:27:49.618Z","comments":true,"path":"2021/12/10/C-Learning-2/","link":"","permalink":"https://mtianming.top/2021/12/10/C-Learning-2/","excerpt":"","text":"指针、数组与字符串用数组表示其实是变相地使用指针；字符串是以空字符结尾地char类型数组。 一、指针 https://blog.csdn.net/soonfly/article/details/51131141 1.1了解指针1.1.1指针类型 从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。 1.1.2指针所指向的类型 当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。 从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。 （把与指针搅和在一起的”类型”这个概念分成**”指针的类型”和”指针所指向的类型”两个概念**，是精通指针的关键点之一。） 1.1.3指针的值 指针的值是XX，就相当于说该指针指向了以XX为首地址的内存区域； 指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。 1.1.4指针的大小：sizeof)(指针类型) 1.2指针的算术运算指针加n减n表示为，p的地址 + n * 指向类型的大小 p + sizeof(type) * n 指针之间可以进行减法运算，但需要保证同一类型；指针之间的加法运算是非法操作，无意义。 1.3运算符&amp;和*123456int a=12; int b; int *p; int **ptr;p=&amp;a; *p=24; ptr=&amp;p;*ptr=&amp;b; **ptr=34; （抛掉解释看懂这个） 1.4指针安全问题越界访问会导致其他区域的值被改变，可能导致严重错误（当然安全性高的编译器会报错） 12345char s=&#x27;a&#x27;;int *ptr;ptr=(int *)&amp;s;*ptr=1298；//最后一条语句不但改变了s 所占的一个字节，还把和s 相临的高地址方向的三个字节也改变了。 1234char a;int *ptr=&amp;a;ptr++;//指针指向了一个未知的区域*ptr=115;//还赋了值 在使用指针的时候要注意指针到底指向了哪里。（特别是数组，虽然可能会有报错提示） 在指针的强制类型转换：ptr1=(TYPE *)ptr2 中，如果sizeof(ptr2的类型)大于sizeof(ptr1 的类型)，那么在使用指针ptr1 来访问ptr2所指向的存储区时是安全的。如果sizeof(ptr2 的类型) 小于sizeof(ptr1 的类型)，那么在使用指针ptr1 来访问ptr2 所指向的存储区时是不安全的。 12345char a = &#x27;a&#x27;;char* p1 = &amp;a;int* p2 = (int*)&amp;a;*p2 = &#x27;a&#x27;;printf(&quot;%c\\n&quot;, a); （上图及代码表示：sizeof(ptr2的类型)小于sizeof(ptr1 的类型)；会导致栈溢出） 二、数组2.1 数组2.1.1 初始化数组 1int arr[5] = &#123;1, 2, 3, 4, 5&#125;; 有时候需要将数组设置为只读，以保护数组内的数据不会被改变： 1const int arr[5] = &#123;1, 2, 3, 4, 5&#125;; 如果部分初始化，其余的值被赋值为0： 123int arr[5] = &#123;1, 2, 3&#125;;printf(&quot;arr[3] = %d\\n&quot;, arr[3]);//打印结果：arr[3] = 0 若初始化时省略方括号内的数字，则编译器会根据数组内的元素个数，自动确定数组大小: 123int arr[] = &#123;1, 2, 3, 4, 5&#125;;printf(&quot;size of arr = %d\\n&quot;, sizeof(arr));//sizeof(数组名)得出的是整个数组的大小//打印结果：size of arr = 20，说明编译器自动赋予了数组五个元素 补充：sizeof是C语言中保留关键字，也可以认为是一种运算符，单目运算符。sizeof实际上是获取了数据类型在内存中所占用的存储空间。 2.1.2 指定初始化器 12345int arr1[6] = &#123;[5] = 1&#125;; //则最后一个元素被赋值为1int arr2[6] = &#123;1, [4] = 10, 11, [0] = 2&#125;;//依次赋值为：2、0、0、0、10、11int arr3[6] = &#123;0&#125;;//全部赋值为0,只有0可以这样做 2.1.3 边界 使用越界的数组会导致使用时改变了其他变量的值（有些编译器会直接报错，中断程序）； 数组的元素编号从0开始； 声明数组的时候使用符号常量表示数组的大小可以增加代码的可读性 123#define COLOR_NUM 10int arr[COLOR_NUM] = &#123;0&#125;;//使用的时候COLOR_NUM即为数组的最后一个元素 2.2 多维数组二维：int arr[2][2] 三维：int arr[2][2][2] 注：多维数组只能够省略第一维，即只能写为arr[][num] 123456int arr[2][2] =&#123; &#123;0,1&#125;; &#123;2,3&#125;;&#125;;//写成这样可以增强可读性//或者int arr[2][2] = &#123;0, 1, 2, 3&#125;;，即当第一行填满后，会自动跳到第二行继续 三、字符串 四、指针与数组 五、指针、数组、函数与字符串 （未完待续…）","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://mtianming.top/tags/C/"}]},{"title":"打字游戏学习历程2-2","slug":"打字游戏学习历程2-2","date":"2021-12-06T13:41:44.000Z","updated":"2021-12-10T05:58:20.334Z","comments":true,"path":"2021/12/06/打字游戏学习历程2-2/","link":"","permalink":"https://mtianming.top/2021/12/06/%E6%89%93%E5%AD%97%E6%B8%B8%E6%88%8F%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B2-2/","excerpt":"","text":"逐个步骤学习一下 1、代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#define _CRT_SECURE_NO_WARNINGS#include &quot;stdio.h&quot;/********************************************************************/int left = 100, top = 20, right = left + 250, bottom = top + 400;char c1, c2;int x = -1, y = -1;int iScoring = 0, iFail = 0;int gameover = 0;/********************************************************************/void ShowScoring(HDC hdc, int x, int y, int iScoring, int iFail)&#123; char szTemp[32]; TextOutA(hdc, x, y, &quot;当前得分：&quot;, strlen(&quot;当前得分：&quot;)); y += 20; sprintf(szTemp, &quot;%d&quot;, iScoring); TextOutA(hdc, x, y, szTemp, strlen(szTemp)); y += 20; TextOutA(hdc, x, y, &quot;当前失误：&quot;, strlen(&quot;当前失误：&quot;)); y += 20; sprintf(szTemp, &quot;%d&quot;, iFail); TextOutA(hdc, x, y, szTemp, strlen(szTemp));&#125;void Fire(HDC hdc, int x, int y1, int y2) &#123; HPEN hOldPen, hNewPen = CreatePen(PS_DASHDOTDOT, 1, RGB(255, 0, 0)); hOldPen = (HPEN)SelectObject(hdc, hNewPen); MoveToEx(hdc, x, y1, NULL); LineTo(hdc, x, y2); Sleep(100); HPEN hNewPen2 = CreatePen(PS_SOLID, 1, RGB(255, 255, 255)); SelectObject(hdc, hNewPen2); MoveToEx(hdc, x, y1, NULL); LineTo(hdc, x, y2); SelectObject(hdc, hNewPen); DeleteObject(hNewPen); DeleteObject(hNewPen2);&#125;void GameOver(HDC hdc, int x, int y)&#123; COLORREF OldColor, NewColor = RGB(rand() % 255, rand() % 255, rand() % 255); OldColor = SetTextColor(hdc, NewColor); TextOutA(hdc, x, y, &quot;GAME OVER !&quot;, strlen(&quot;GAME OVER !&quot;)); SetTextColor(hdc, OldColor);&#125;/********************************************************************/LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; switch (message) &#123; /*用户代码开始*/ case WM_TIMER: switch (wParam) &#123; case 1: y += iScoring / 10 + 1; if(y &gt; bottom - 40) &#123; gameover = 1; KillTimer(hWnd, 1); SetTimer(hWnd, 2, 300, NULL); &#125; InvalidateRect(hWnd, 0, 0); break; case 2: InvalidateRect(hWnd, 0, 0); break; &#125; break; case WM_CHAR: &#123; c2 = (wParam &gt;= &#x27;a&#x27; &amp;&amp; wParam &lt;= &#x27;z&#x27;) ? wParam + &#x27;A&#x27; - &#x27;a&#x27; : wParam; HDC hdc = GetDC(hWnd); Fire(hdc, left + 5 + (c2 - &#x27;A&#x27;) * 9 + 4, top, bottom); ReleaseDC(hWnd, hdc); if (c2 == c1) &#123; c1 = rand() % 26 + &#x27;A&#x27;; x = left + 5 + (c1 - &#x27;A&#x27;) * 9; y = top; iScoring = iScoring + 1; &#125; else iFail = iFail + 1; &#125; break;/*用户代码结束*/ case WM_COMMAND: &#123; int wmId = LOWORD(wParam); // 分析菜单选择: /*用户代码开始*/ switch (wmId) &#123; case ID_START: if (gameover == 1) KillTimer(hWnd, 2); gameover = 0; iScoring = 0; iFail = 0; c1 = rand() % 26 + &#x27;A&#x27;; x = left + 5 + (c1 - &#x27;A&#x27;) * 9; y = top; SetTimer(hWnd, 1, 10, NULL); break;/*用户代码结束*/ case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; &#125; break; case WM_PAINT: &#123; PAINTSTRUCT ps; HDC hdc = BeginPaint(hWnd, &amp;ps); // TODO: 在此处添加使用 hdc 的任何绘图代码... /*用户代码开始*/ DrawBk(hdc, left, top, right, bottom); ShowScoring(hdc, right + 20, top + 50, iScoring, iFail); if (gameover) GameOver(hdc, left + 80, top + 130); else &#123; char szTemp[8]; sprintf(szTemp, &quot;%c&quot;, c1); TextOutA(hdc, x, y, szTemp, strlen(szTemp)); &#125;/*用户代码结束*/ EndPaint(hWnd, &amp;ps); &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125;/********************************************************************/ (整体上添加的代码) 代码解释1.12345678910111213void ShowScoring(HDC hdc, int x, int y, int iScoring, int iFail)&#123; char szTemp[32]; TextOutA(hdc, x, y, &quot;当前得分：&quot;, strlen(&quot;当前得分：&quot;)); y += 20; sprintf(szTemp, &quot;%d&quot;, iScoring); TextOutA(hdc, x, y, szTemp, strlen(szTemp)); y += 20; TextOutA(hdc, x, y, &quot;当前失误：&quot;, strlen(&quot;当前失误：&quot;)); y += 20; sprintf(szTemp, &quot;%d&quot;, iFail); TextOutA(hdc, x, y, szTemp, strlen(szTemp));&#125; 1）HDC hdc：当需要在显示器上（当然包括打印机等设备上）绘图时，或者写文字的时候，需要取得设备的上下文句柄，即HDC。 2) TextOut函数BOOL TextOutA(HDC hdc, int x, int y, LPCSTR IpString, int c)； 关于这个函数我们需要了解什么呢？没错，会用就行了。 The TextOut function writes a character string at the specified location, using the currently selected font, background color, and text color. 1.TextOut函数使用当前选定的字体、背景颜色和文本颜色在指定位置写入字符串。 2.TextOut函数若后缀为A（TextOutA），则表示普通字符输出，若后缀为W（TextOutW），则表示宽字符输出。 ​ 补充：宽字符是什么？ Unicode 是支持所有字符集（包括无法以单个字节表示的字符集）的规范。为国际市场编程时应考虑使用 Unicode 或多字节字符集 (MBCS)，或使程序能够通过更改开关来生成支持两种字符集之一的程序。 宽字符是双字节多语言字符代码。在当今的全球计算业内使用的大多数字符（包括技术符号和特殊的发布字符），都可以根据 Unicode 规范表示为宽字符形式。无法以 1 个宽字符表示的字符可以通过 Unicode 的代理项功能以 Unicode 对表示。由于每个宽字符总是以固定的 16 位大小表示，因此使用宽字符可以简化使用国际字符集进行的编程。 通常，宽字符在内存中占用的空间比多字节字符多，但处理速度更快。另外，在多字节编码中一次只能表示一个区域设置，而世界上的所有字符集都同时以 Unicode 表示形式表示。 3.返回类型：bool（布尔）类型 bool类型常见于C++（当然如果要在C语言中使用的话，需要导入stdbool.h的头文件），bool类型中，true代表1（即真），false代表0（假）。 4.一些参数 x：指定用于字符串对齐的基准点的逻辑x坐标 y：指定用于字符串对齐的基准点的逻辑y坐标 LPCSTR IpString：指向要绘制的字符串的指针。字符串不需要以零结尾（不必以0结尾），因为 cchString 指定字符串的长度。 c：指定字符串的长度。 5.再来看我们写（chao）的： TextOutA(hdc, x, y, “当前得分：”, strlen(“当前得分：”)); hdc不用管他，一般直接写上去就ok了；x，y表示坐标，即我们要在屏幕这个二维上的哪个地方打印这一字符串；“当前得分：”，为什么IpString明明是，指向要绘制的字符串的指针，而我们确实直接输入了一个字符串呢？相信学过C基础的各位，都知道在讲指针与字符串的时候讲过。 注：字符串、数组、指针的内容另写博文 （中途完结。。。由于这部分被建议不用学习，改用的时候移植代码即可）","categories":[],"tags":[{"name":"Win 桌面应用程序设计","slug":"Win-桌面应用程序设计","permalink":"https://mtianming.top/tags/Win-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"TypingGame2-1","slug":"TypingGame2-1","date":"2021-12-05T04:45:21.000Z","updated":"2021-12-07T12:50:41.914Z","comments":true,"path":"2021/12/05/TypingGame2-1/","link":"","permalink":"https://mtianming.top/2021/12/05/TypingGame2-1/","excerpt":"","text":"抄写代码试着照着书上做了一遍，发现效果还可以，把代码发在这里 1.设置选项-开始游戏 输入”开始游戏” 在杂项-ID中输入”ID_START” 2.复制代码1.头文件与预处理器： 123#define _CRT_SECURE_NO_WARNINGS#include &quot;stdio.h&quot; 2.全局变量 123456int left = 100, top = 20, right = left + 250, bottom = top + 400;char c1, c2;int x = -1, y = -1;int iScoring = 0, iFail = 0;int gameover = 0; 3.一些函数将以下函数放在： 123456void DrawBk(HDC hdc, int x1, int y1, int x2, int y2)&#123; Rectangle(hdc, x1, y1, x2, y2); char s[100] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; TextOutA(hdc, x1 + 5, y2 - 25, s, strlen(s));&#125; 12345678910111213void ShowScoring(HDC hdc, int x, int y, int iScoring, int iFail)&#123; char szTemp[32]; TextOutA(hdc, x, y, &quot;当前得分：&quot;, strlen(&quot;当前得分：&quot;)); y += 20; sprintf(szTemp, &quot;%d&quot;, iScoring); TextOutA(hdc, x, y, szTemp, strlen(szTemp)); y += 20; TextOutA(hdc, x, y, &quot;当前失误：&quot;, strlen(&quot;当前失误：&quot;)); y += 20; sprintf(szTemp, &quot;%d&quot;, iFail); TextOutA(hdc, x, y, szTemp, strlen(szTemp));&#125; 123456789101112131415void Fire(HDC hdc, int x, int y1, int y2) &#123; HPEN hOldPen, hNewPen = CreatePen(PS_DASHDOTDOT, 1, RGB(255, 0, 0)); hOldPen = (HPEN)SelectObject(hdc, hNewPen); MoveToEx(hdc, x, y1, NULL); LineTo(hdc, x, y2); Sleep(100); HPEN hNewPen2 = CreatePen(PS_SOLID, 1, RGB(255, 255, 255)); SelectObject(hdc, hNewPen2); MoveToEx(hdc, x, y1, NULL); LineTo(hdc, x, y2); SelectObject(hdc, hNewPen); DeleteObject(hNewPen); DeleteObject(hNewPen2);&#125; 1234567void GameOver(HDC hdc, int x, int y)&#123; COLORREF OldColor, NewColor = RGB(rand() % 255, rand() % 255, rand() % 255); OldColor = SetTextColor(hdc, NewColor); TextOutA(hdc, x, y, &quot;GAME OVER !&quot;, strlen(&quot;GAME OVER !&quot;)); SetTextColor(hdc, OldColor);&#125; （最后找到这个函数，并将其整体用下列代码替换） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; switch (message) &#123; /*用户代码开始*/ case WM_TIMER: switch (wParam) &#123; case 1: y += iScoring / 10 + 1; if(y &gt; bottom - 40) &#123; gameover = 1; KillTimer(hWnd, 1); SetTimer(hWnd, 2, 300, NULL); &#125; InvalidateRect(hWnd, 0, 0); break; case 2: InvalidateRect(hWnd, 0, 0); break; &#125; break; case WM_CHAR: &#123; c2 = (wParam &gt;= &#x27;a&#x27; &amp;&amp; wParam &lt;= &#x27;z&#x27;) ? wParam + &#x27;A&#x27; - &#x27;a&#x27; : wParam; HDC hdc = GetDC(hWnd); Fire(hdc, left + 5 + (c2 - &#x27;A&#x27;) * 9 + 4, top, bottom); ReleaseDC(hWnd, hdc); if (c2 == c1) &#123; c1 = rand() % 26 + &#x27;A&#x27;; x = left + 5 + (c1 - &#x27;A&#x27;) * 9; y = top; iScoring = iScoring + 1; &#125; else iFail = iFail + 1; &#125; break;/*用户代码结束*/ case WM_COMMAND: &#123; int wmId = LOWORD(wParam); // 分析菜单选择: /*用户代码开始*/ switch (wmId) &#123; case ID_START: if (gameover == 1) KillTimer(hWnd, 2); gameover = 0; iScoring = 0; iFail = 0; c1 = rand() % 26 + &#x27;A&#x27;; x = left + 5 + (c1 - &#x27;A&#x27;) * 9; y = top; SetTimer(hWnd, 1, 10, NULL); break;/*用户代码结束*/ case IDM_ABOUT: DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About); break; case IDM_EXIT: DestroyWindow(hWnd); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; &#125; break; case WM_PAINT: &#123; PAINTSTRUCT ps; HDC hdc = BeginPaint(hWnd, &amp;ps); // TODO: 在此处添加使用 hdc 的任何绘图代码... /*用户代码开始*/ DrawBk(hdc, left, top, right, bottom); ShowScoring(hdc, right + 20, top + 50, iScoring, iFail); if (gameover) GameOver(hdc, left + 80, top + 130); else &#123; char szTemp[8]; sprintf(szTemp, &quot;%c&quot;, c1); TextOutA(hdc, x, y, szTemp, strlen(szTemp)); &#125;/*用户代码结束*/ EndPaint(hWnd, &amp;ps); &#125; break; case WM_DESTROY: PostQuitMessage(0); break; default: return DefWindowProc(hWnd, message, wParam, lParam); &#125; return 0;&#125; 于是乎，当你Copy完以上代码后你就能获得一个桌面小游戏w （未完待续…）","categories":[],"tags":[{"name":"Win 桌面应用程序设计","slug":"Win-桌面应用程序设计","permalink":"https://mtianming.top/tags/Win-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"打字游戏学习历程1.1","slug":"打字游戏学习历程1-1","date":"2021-12-04T13:54:42.000Z","updated":"2021-12-05T03:23:12.103Z","comments":true,"path":"2021/12/04/打字游戏学习历程1-1/","link":"","permalink":"https://mtianming.top/2021/12/04/%E6%89%93%E5%AD%97%E6%B8%B8%E6%88%8F%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B1-1/","excerpt":"","text":"Windows APIAPI（Application Programming Interface） 1.Start123456789101112#include &quot;iostream&quot;#include &quot;Windows.h&quot;using namespace std;int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)&#123; cout &lt;&lt; &quot;Hallo C++ !&quot; &lt;&lt; endl; MessageBox(NULL, TEXT(&quot;Hallo C++ !&quot;), TEXT(&quot;标题&quot;), MB_OK); return 0;&#125; \\\\（第一个API函数） 用WinMain()代替main()更能体现我们准备做的程序是一个Windows程序 2.API函数分类Windows API包括几千个可调用的函数，它们大致可以分为以下几个大类： 基本服务； 组件服务; 用户界面服务； 图形多媒体服务; 消息和协作； 网络； Web服务。 Windows API所提供的七类功能详细介绍： 1.基础服务（Base Services） 提供对Windows系统可用的基础资源的访问接口。比如象：文件系统（file system）、外部设备（device）、，进程（process）、线程（thread）以及访问注册表（Windows registry）和错误处理机制（error handling）。 2.图形设备接口（GDI） 提供功能为：输出图形内容到显示器、打印机以及其他外部输出设备。 3.图形化用户界面（GUI） 提供的功能有创建和管理屏幕和大多数基本控件（control），比如按钮和滚动条。接收鼠标和键盘输入，以及其他与GUI有关的功能。 4.通用对话框链接库（Common Dialog Box Library） 为应用程序提供标准对话框，比如打开/保存文档对话框、颜色对话框和字体对话框等等。 5.通用控件链接库（Common Control Library） 为应用程序提供接口来访问操作系统提供的一些高级控件。比如像：状态栏（status bar）、进度条（progress bars）、工具栏（toolbar）和标签（tab）。 6.Windows外壳（Windows Shell） 作为Windows API的组成部分，不仅允许应用程序访问Windows外壳提供的功能，还对之有所改进和增强。 7.网络服务（Network Services） 为访问操作系统提供的多种网络 功能提供接口。它包括NetBIOS、Winsock、NetDDE及RPC等。 3.程序入口函数WinMain()12345678910111213#include &quot;iostream&quot;#include &quot;Windows.h&quot;using namespace std;int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)&#123; cout &lt;&lt; &quot;Hallo C++ !&quot; &lt;&lt; endl; MessageBox(NULL, TEXT(&quot;Hallo C++ !&quot;), TEXT(&quot;标题&quot;), MB_OK); return 0;&#125; WinMain 函数有 4 个参数：hInstance、hPrevInstance、lp CmdLine、nCmdShOW。 第一个参数是 hInstance，数据类型是HINSTANCE，此参数表示应用程序本次运行实例的句柄。 第二个参数是 hPrevInstance，数据类型也是 HINSTANCE，表示应用程序之前运行的句柄，但是在实际应用中，此参数始终为 NULL。 第三个参数 lpCmdLine 是运行时参数。如在 cmd命令行中运行“start.ext Command Arguments”，那么lpCmdLine就指向字符串“Command Arguments”，作用与C语言中main函数的参数作用类似。数据类型LPSTR是Windows API常见的字符串类型。 最后一个参数是 nCmdShow，数据类型是int，表示应用程序窗口（如果有）的显示状态。WinMain 函数的返回类型是 int 型的。 （未完待续…）","categories":[],"tags":[{"name":"Win 桌面应用程序设计","slug":"Win-桌面应用程序设计","permalink":"https://mtianming.top/tags/Win-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}]},{"title":"C_Learning_1_1","slug":"C-Learning-1","date":"2021-12-01T05:05:17.000Z","updated":"2021-12-01T13:14:23.361Z","comments":true,"path":"2021/12/01/C-Learning-1/","link":"","permalink":"https://mtianming.top/2021/12/01/C-Learning-1/","excerpt":"","text":"C_Learning_1_1 （预告：本文是融合怪） 使用C语言的7个步骤1.定义程序的目标 2.设计程序 3.编写代码 4.编译 5.运行程序 6.测试和调试程序 7.维护和修改程序 提高程序的可读性1.一致的缩进代码缩进方式是有挺多中的，一致的缩进可以为查看代码，检查代码提供很大的便利 例： 我们来对比一下： 12345678910if(Read_C1==0)&#123; HAL_Delay(10); if(Read_C1==0) HAL_TIM_PWM_Start(&amp;htim4,TIM_CHANNEL_2); __HAL_TIM_SET_AUTORELOAD(&amp;htim4,2000); __HAL_TIM_SET_COMPARE(&amp;htim4,TIM_CHANNEL_2,1000); HAL_Delay(100); __HAL_TIM_SET_COMPARE(&amp;htim4,TIM_CHANNEL_2,0); motor_adjust();&#125; 12345678910if(Read_C1==0)&#123; HAL_Delay(10); if(Read_C1==0) HAL_TIM_PWM_Start(&amp;htim4,TIM_CHANNEL_2); __HAL_TIM_SET_AUTORELOAD(&amp;htim4,2000); __HAL_TIM_SET_COMPARE(&amp;htim4,TIM_CHANNEL_2,1000); HAL_Delay(100); __HAL_TIM_SET_COMPARE(&amp;htim4,TIM_CHANNEL_2,0); motor_adjust();&#125; 在这个例子中你会发现，有两个if，而第二个if那里你会发现有一个没有缩进，这就给我们读代码的时候带来了挺大的困扰（即便是本人写的，有时也会觉得很烦） 这里只出现了一次，若是很多嵌套你给我整个乱缩进，我可能会带着想敲人的心情先把他整理好再看的 2.避免冗余的注释注释是一件很棒的，可以很有效的提高代码的可读性（比如说你的某个小伙伴看不懂你没有注释的代码，就会来烦打扰你，就会导致一个团队的工作效率降低） but要适当的注释，精炼注释，否则你的小伙伴看到你一条注释一条代码的程序也会觉得很烦 （一句话能说明白的，咱就不要说得那么冗长） 3.代码分组同一类凑在一起会好看些。 通过注释、空行等方法。（简洁明了） 4.命名方案1.对于临时变量，我们可以将它们一致命名为i（或者其他单一字母 2.对于一些有意义的量，我们可以给他们命个名，就比如说计数器，我们可以命名为cnt而不是i，这样好让读代码的人可以知道你这个变量是干啥的，而不是i,j,k,a,b,c如果单片机里的引脚都这样命名，你可能会想给他寄刀片好吃的。3.最后，对于量的命名，我们需要统一用一种命名方式，当然，有挺多的其实，我个人比较喜欢用下划线（key_play 表示用矩阵键盘来弹电子琴；key_scan表示对矩阵键盘进行扫描） 5.DRY Principle（干燥原理）Ctrl + C，Ctrl + V作为当代大学生最常用地快捷键，在代码中确实要慎用地 DRY意思是不要重复，即DIE: Duplication is Evil.（复制是邪恶的） 复制粘贴会让你的代码变得十分冗杂 一段代码实现的功能应当是它独有的，我们往往能够找到合适的办法，将一大段复制型代码转化为一小段（当然并不是说代码越渐短越高效） “每一条知识都必须在一个系统中有一个单一的、明确的、权威的表示。” 遵守以上原则，我们能够大大缩短代码冗杂都度 （最后分享一个离谱的案例：有人用if语句叠了几万行代码） 6.避免太多嵌套123456if（a） if（b） if（c） if（d） if（e） ........ 这还只是if，太多嵌套的话会导致你很难跟踪调试 （你知道的，C语言考试题里面经常来这种嵌套，还只是三层就已经够恶心人的了） 7.限制行的长度1printf(&quot;The China-Laos Railway, due to open this week, is a docking project between the China-proposed Belt and Road Initiative and Laos&#x27; strategy to convert itself from a landlocked country to a land-linked hub. It will bring new opportunities and provide huge momentum in strengthening Laos&#x27; economy. The train route will connect the Chinese city of Kunming to the Lao capital Vientiane, with grand plans for high-speed rail to ultimately snake down through Thailand and Malaysia to Singapore.&quot;); 如果放在编译器里的话就是天灾，而且这对眼睛不好，最好还是不要超过80吧qwq 小补充： 这里就有三种方式可以应对这种超长代码： 1.使用多个printf() 2.用反斜杠\\ 1234printf(&quot;The China-Laos Railway, due to open this week, \\is a docking project between the China-proposed Belt and \\Road Initiative and Laos&#x27; strategy to convert itself from \\a landlocked country to a land-linked hub.\\n&quot;); 3.用ANSI C引入的字符串&#39; &#39;连接 12printf(&quot;hallo&quot; &quot;i&quot; &quot;am&quot; &quot;a boy&quot;); //即&quot; &quot; 8.用多个文件来实现一个工程从理论上来讲，你可以把所有项目写在一个源文件中，但。。你维护的时候或者别人读的时候，绝对是噩梦般的体验 这个是后话，先知道就好了（其实晚自习要下课了） （未完待续..）","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://mtianming.top/tags/C/"}]},{"title":"我的第一篇博文","slug":"我的第一篇博文","date":"2021-11-30T10:36:59.000Z","updated":"2021-12-01T07:34:26.324Z","comments":true,"path":"2021/11/30/我的第一篇博文/","link":"","permalink":"https://mtianming.top/2021/11/30/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/","excerpt":"","text":"My First Blog这里是我的第一篇博文","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://mtianming.top/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-11-30T09:58:43.544Z","updated":"2021-11-30T09:58:43.544Z","comments":true,"path":"2021/11/30/hello-world/","link":"","permalink":"https://mtianming.top/2021/11/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"https://mtianming.top/tags/%E6%95%B0%E5%AD%A6/"},{"name":"高等数学","slug":"高等数学","permalink":"https://mtianming.top/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"},{"name":"单片机学习","slug":"单片机学习","permalink":"https://mtianming.top/tags/%E5%8D%95%E7%89%87%E6%9C%BA%E5%AD%A6%E4%B9%A0/"},{"name":"视觉","slug":"视觉","permalink":"https://mtianming.top/tags/%E8%A7%86%E8%A7%89/"},{"name":"C","slug":"C","permalink":"https://mtianming.top/tags/C/"},{"name":"Win 桌面应用程序设计","slug":"Win-桌面应用程序设计","permalink":"https://mtianming.top/tags/Win-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"hexo","slug":"hexo","permalink":"https://mtianming.top/tags/hexo/"}]}